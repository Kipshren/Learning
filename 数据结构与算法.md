#  1_基本概念

  

## 数据结构和算法

==数据结构==：把简单的数据组装成有特殊结构的数据类型。用数据结构解决某种问题的方法就是算法。



## 算法复杂度

### 时间复杂度

事后统计法：执行程序后算出运行时间，如果运行时间过长就不妥。而且计算机的硬、软件都会影响运行时间，只有在运行环境相同下，才能度量出程序本身的时间

事前估计法：分析时间复杂度



​	**时间频度**：算法中语句执行的次数。记为T(n)

​	*忽略常数项*

<img src="D:\NOTES\zattachment\image-20231112213615553.png" alt="image-20231112213615553" style="zoom:80%;" />

随着n的变大，曲线无线接近，说明常数项20、10可以忽略

​	*忽略低次项*

<img src="D:\NOTES\zattachment\image-20231112213817396.png" alt="image-20231112213817396" style="zoom:80%;" />

随着n的变大，低次项之间的增长差距越来越小，说明低次项可以忽略

​	*忽略系数*

<img src="D:\NOTES\zattachment\image-20231112213924393.png" alt="image-20231112213924393" style="zoom:80%;" />

随着n的变大，增长规模小时：系数增长规模忽略不计。增长规模大时：他们之间比例接近于常数，说明系数跟次数(T(n))无关，可以忽略



==时间复杂度==：描述程序运行的时间，用O(f(n))表示，一般都是用时间频度表示时间复杂度，即O(f(n))=T(n)

计算时间复杂度：

1. 用1代替常数项
2. 去掉低次项
3. 去掉系数

某些情况下，T(n)不同但O(f(n))是相同的，比如n^2^+7n+6和3n^2^+2n+2时间复杂度都是O(n^2^)



​	**常见时间复杂度**

1) 常数阶O(1)
2) 对数阶O($$log_2 n$$)
3) 线性阶O(n)
4) 线性对数阶O(n$$log_2 n$$)
5) 平方阶O(n^2^)
6) 立方阶O(n^3^)
7) k次方阶O(n^k^)
8) 指数阶O(2^n^)

<img src="D:\NOTES\zattachment\image-20231112215821288.png" alt="image-20231112215821288" style="zoom:67%;" />

复杂度：O(2^n^)>O(n^k^)>O(n^3^)>O(n^2^)>O(n$$log_2 n$$)>O(n)>O($$log_2 n$$)>O(1) 

复杂度越大，效率越低

```java
//常数阶：没涉及到循环等复杂结构，单个语句的都是常数阶
int i = 1,j = 2;
m = i + j

//对数阶
i=1
while(i<n){
    i = i * 2;
}
设语句执行x次循环结束，那么2^x=n，得出执行x=log_2(n)次

//线性阶
for(int i = 1 ; i <= n ; i++)
这行T(n)=n+1因为最后还需要判断 n+1!=n 的 ，但O(n) = n
    
//线性对数阶
for(m=1;m<n;m++){//线性阶
    i=1;
    while(i<n){//对数阶
        i=i*2;
    }
}    //循环套循环，T(n)就是相乘
    
//平方阶
for(i=1;i<=n;i++){
    for(j=1;j<n=;j++) //两个线性阶的循环嵌套
}     
```



​	**平均时间复杂度和最坏时间复杂度**

平均时间复杂度是所有输入的实例均可能等概率出现的情况下的运行时间

最坏时间复杂度程序可能运行的最长时间

<img src="D:\NOTES\zattachment\image-20231112221309739.png" alt="image-20231112221309739" style="zoom: 50%;" />



### 空间复杂度

算法的空间复杂度是该算法耗费的存储空间。有的算法规模越大，占用的存储空间越多。但用户体验上来看，更看重程序的执行速度，一些缓存产品和算法的本质就是用空间换时间



# 2_线性表

## 数组

==稀疏数组==指的是一个数组中大部分元素为0或相同值，只有少部分拥有不同的值。这样就导致这个数组空间利用率很低，所以可以压缩行、列，只存储少部分不同元素的位置信息和值，从而大大减少了存储空间的使用。

<img src="D:\NOTES\zattachment\image-20231030212256089.png" alt="image-20231030212256089" style="zoom:67%;" />

稀疏数组的压缩和解压操作：

​	压缩：统计总数组的异值个数x->创建x行3列的稀疏数组->首行放总数组行数、列数，其余行依次放置异值的索引和值

​	解压：根据稀疏数据的首行创建出总数组->遍历其余行，把异值投放入总数组



## 链表

==链表==是存储空间不连续的线性表，由单个结点连接而成，每个结点有数据域和指针域，指针域存放着指示结点关系的信息。



### 单链表







# 3_队列

Queue：遵循先进先出FIFO（First In First Out）原则的数据结构。









# 4_栈





# 排序

<img src="D:\NOTES\zattachment\image-20231112202316735.png" alt="image-20231112202316735" style="zoom:80%;" />





## 冒泡排序

冒泡排序(BubbleSort)基本思想：从前往后，依次比较相邻的元素，若发现逆序则交换，使值较大的元素逐渐移向后部，就像水底的水泡一样逐渐上冒。

优化：若一趟排序下来，没有元素交换，就说明序列已是正序，即可退出

![算法—冒泡排序，选择排序-CSDN博客](D:\NOTES\zattachment\aHR0cDovL3d4Mi5zaW5haW1nLmNuL2xhcmdlLzAwNUJWcnFpZ3kxZnVjaGxmaW1iNGczMGx2MDZ1azFrLmdpZg.gif)







## 选择排序

选择排序(selectSort)基本思想： 







## 插入排序







## 希尔排序







## 快速排序







## 归并排序







## 基数排序





# 查找







# 哈希表





# 树

Q：为什么需要树？

在之前的存储结构中，数组的优点是遍历、检索速度快，但插入、删除速度慢。链表的优点是插入、删除速度快，而遍历、检索的速度慢。

那么树就可以结合这两个结构的优点：既可以保证检索的速度又可以方便的插入、删除数据。



## 常用术语

<img src="D:\NOTES\zattachment\image-20231123170939129.png" alt="image-20231123170939129" style="zoom:67%;" />

1. 根节点：树的第一个节点
2. 父节点：相对于子结点，子节点的上一个节点
3. 子节点：相对于父结点，父节点的下一个节点
4. 叶子节点：没有子节点的节点
5. 节点的权：节点里面的值
6. 路径：从树的任意节点出发到另一节点的序列，至少包含一个节点（这个节点不包括本身）
7. 路径长度：从根节点到这一节点所有路径树的和（就是路径上节点的数目），比如H节点的路径长度就是：3
8. 层：从根节点第一层开始到最后一层
9. 子树：将其他节点看作新的树，最上面是新的根节点
10. 树的高度：最大层数
11. 森林：多颗子树构成的森林



## 二叉树

==二叉树==是单每个节点最多只有两个子节点的树



满二叉树：所有叶子节点都在最后一层

<img src="D:\NOTES\zattachment\image-20231123180210450.png" alt="image-20231123180210450" style="zoom:50%;" />

完全二叉树：所有叶子节点都在最后一层或倒数第二层，且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续

<img src="D:\NOTES\zattachment\image-20231123180338155.png" alt="image-20231123180338155" style="zoom:50%;" />



### 二叉树遍历

二叉树有三种遍历： 分别按根节点遍历的次序判断

1. 前序遍历（PreOrder）：根节点->左子节点->右子节点
2. 中序遍历（InOrder）：左子节点->根节点->右子节点
3. 后序遍历（PostOrder）：左子节点->右子节点->根节点

<img src="D:\NOTES\zattachment\image-20231123182603106.png" alt="image-20231123182603106" style="zoom:80%;" />

进入顺序：从根节点顺沿下去，下面的节点都看作子树，子树的遍历都按照Pre,In,Post的顺序来，那么大体上来说就是根节点、左子树、右子树之间的遍历



### 二叉树检索

<img src="D:\NOTES\zattachment\image-20231124084438891.png" alt="image-20231124084438891" style="zoom:50%;" />

前序查找：

1. 先判断当前根节点是否是要查找的，是：返回节点，否：判断左子节点是否为空，如果不为空则递归查找
2. 左递归查找到，则返回节点，若没有则判断右子结点是否为空，不为空则递归右子结点查找

中序查找：

1. 先判断当前节点的左子结点是否为空，不为空则递归中序查找
2. 左递归没找到则判断当前根节点是否是要查找值，若不是，则判断右子结点是否为空，再右递归

后序查找：

1. 先判断当前节点的左子结点是否为空，不为空则递归后序查找
2. 左递归没有找到，则判断当前节点的右子结节点是否为空，不为空则右递归，如果最后没找到则判断根节点



### 二叉树删除

- 删除节点是叶子节点，则删除节点

- 删除节点是非叶子节点，则删除子树

1. 如果树只有一个根节点，则将二叉树置空
2. 因为二叉树是单向的，所以必须判断的是当前节点的子结点是否是删除节点，而不能判断当前节点
3. 如果当前节点的左子节点非空，且就是删除节点，那么`this.left=null`
4. 如果当前节点的右子节点非空，且就是删除节点，那么`this.right=null`
5. 如果没有找到删除节点，则先向左子树递归查找，再右子树递归查找



### 顺序存储二叉树

数组存储和树存储间可以相互转换，==顺序存储二叉树==就是将二叉树的节点存入数组中

<img src="D:\NOTES\zattachment\image-20231124092226357.png" alt="image-20231124092226357" style="zoom:67%;" />

特点

- 顺序存储二叉树一般只考虑完全二叉树，仍可以在数组中前中后序存储
- 第n个节点的左子节点为2n+1
- 第n个节点的右子节点为2n+2
- 第n个节点的父节点为(n-1)/2



### 线索化二叉树

==线索化==就是充分利用节点的空指针，左指针指向前驱，右指针指向后继。

n个节点的二叉树中有n+1（2n-(n-1)，2n个指针，除根节点外，减去n个节点占用的指针）个空指针域

前驱、后继节点是按照前中后序遍历后的序列判断的

<img src="D:\NOTES\zattachment\image-20231124102757245.png" alt="image-20231124102757245" style="zoom:80%;" />



## 树的应用



### 堆排序

堆排序是利用堆这种数据结构设计的排序算法，是一种选择排序，最好、最坏、平均时间复杂度都为O(nlogn)，不稳定排序

一般升序采用大顶堆，降序采用小顶堆

1. 将待排序序列构造成大顶堆
2. 根节点（最大节点）与末尾节点交换，那么末尾节点是最大值，且将末尾节点从树中忽略掉
3. 将剩余的n-1个元素重新构造大顶堆，循环上面步骤，最后得到有序序列



**大顶堆和小顶堆**

堆是具有特殊性质的完全二叉树，当前节点值大于或等于左右子节点值为大顶堆，当前节点值小于或等于左右子节点值为小顶堆（子节点之间没有大小关系，否则就是二叉排序树）

<img src="D:\NOTES\zattachment\image-20231124104146597.png" alt="image-20231124104146597" style="zoom: 50%;" />

**图解**

![image-20231124182227595](D:\NOTES\zattachment\image-20231124182227595.png)



### 哈夫曼树

当树的带权路径长度（wpl）达到最小时，被称为最优二叉树、==哈夫曼树==（HuffmanTree），权值较大的节点离根节点越近

树的带权路径长度：所有**叶子节点**的 权值\*路径长度（带权路径长度）之和，Weighted Path Length



<img src="D:\NOTES\zattachment\image-20231124183218077.png" alt="image-20231124183218077" style="zoom: 80%;" />

构造哈夫曼树：

1. 先进行升序排序，将每一个元素看成最简单的二叉树
2. 取出根节点权值最小的两棵二叉树，组成新的二叉树（左小右大），根节点是两个取出的根节点之和
3. 再将这棵新的二叉树，以根节点权值大小重新排序



![image-20231124185847817](D:\NOTES\zattachment\image-20231124185847817.png)



### 哈夫曼编码

哈夫曼编码是通过哈夫曼树实现的一种算法，是一种可变字长编码（VLC）也是被称为最佳编码，广泛地用于数据文件压缩



通信领域中的信息处理方式：

**定长编码**

<img src="D:\NOTES\zattachment\image-20231126201111013.png" alt="image-20231126201111013" style="zoom:80%;" />



**变长编码**

<img src="D:\NOTES\zattachment\image-20231126202002876.png" alt="image-20231126202002876" style="zoom:80%;" />



**哈夫曼编码**

但上面的变长编码不是前缀编码，==前缀编码==是字符的编码都不能是其他字符编码的前缀，比如1011中的1是a，10是i，101是l就不是前缀编码，那么会导致编码的混淆

哈夫曼编码就是前缀编码

![image-20231126221807458](D:\NOTES\zattachment\image-20231126221807458.png)



### 二叉排序树

==二叉排序树BST==（Binary Sort Tree）中任一非叶子节点的左子节点小于这一节点，右子节点大于这一节点（相同权值的节点可以放左或右节点）。实现高效地数据查找和删除、插入



**BST创建**

<img src="D:\NOTES\zattachment\image-20231126223502958.png" alt="image-20231126223502958" style="zoom:80%;" />



**BST删除**

1. 删除叶子节点

- 找到待删除的节点
- 找到其父节点
- 判断待删除节点是左/右子节点，然后删除



2. 删除只有一棵子树的节点（不是删除子树），例如删除节点 1

- 找到待删除节点
- 找到父节点并判断待删除节点是左/右子节点
- 判断待删除节点的子节点是左/右
- 将父节点的待删除节点的指向改为其子节点，PreNode.left = Node.right（删除节点1）



3. 删除右两棵子树的节点，例如删除3、10、7

- 找到待删除的节点
- 找到其父节点
- 从待删除节点的右子树找出最小值节点替换掉待删除节点，然后删除掉最小值节点（也可以从左子树中找出最大值）



删除根节点情况：



### 平衡二叉树

平衡二叉树AVL（Self-balancing Binary Search Tree），保证了查询效率较高（是在二叉排序树的基础上）。其左右两棵子树的高度差不超过1，并且左右两个子树都是一棵平衡二叉树

在数组：1,2,3,4,5,6中，二叉排序树的左子树全为空，更像个单链表，插入速度没影响但检索速度大大减低，比单链表还要慢。那么就需要调整成平衡二叉树

<img src="D:\NOTES\zattachment\image-20231127191258495.png" alt="image-20231127191258495" style="zoom:67%;" />

**单旋转**

左旋转中，右子树的层数更高，需要将两侧的子树层数平衡一下。进行的操就是右节点左移，将层数多的子树移一个节点到层数少的子树，导致多的层数-1

<img src="D:\NOTES\zattachment\image-20231127194508653.png" alt="image-20231127194508653" style="zoom:80%;" />

右旋转的话，条件转换下就可



**双旋转**

<img src="D:\NOTES\zattachment\image-20231127194702539.png" alt="image-20231127194702539" style="zoom: 67%;" />

这棵树右旋转仍然是非平衡二叉树，那么需要双旋转

上面的平衡二叉树满足：

1. 符合右旋转
2. 左子树的右子树层数大于左子树（即左旋转，**两个相反的旋转**）

那么可以：

1. 先对根节点的左子树进行左旋转
2. 再对整棵树进行右旋转



### 多路查找树

#### B树

B树（多叉树）：不只两个子结点且节点中不只一个数据的树，通过将二叉树重新组织，降低高度，提高效率

每个节点最多有多少个子节点称为树的阶

M阶的B树中满足：

1. 叶子节点和非叶子节点都存放实际数据
2. 所有叶子节点都在同一层（满二叉树）



#### 2-3树

最简单的B树结构，2-3树就是2节点和3节点构成的树

2-3树满足：

1. 所有叶子节点都在同一层（满二叉树）
2. 2节点要么有两个子结点要不没有子节点（3节点同理）
3. 只有2节点和3节点
4. 按排序插入一个数到本层时，若不能满足上面条件，则需要拆分树。从上层拆，如果上层满则拆本层





#### B+树、B*树1

B+树是B树的变体，所有的数据都存放在叶子节点的链表中，非叶子节点是索引（不是数据，就像文件夹按分类命名），更快地找到文件

<img src="D:\NOTES\zattachment\image-20231128120614206.png" alt="image-20231128120614206" style="zoom:80%;" />

B*树

B+树的变体，非叶子节点再增加指向兄弟的指针（索引之间有指针连接）

B*树定义了非叶子节点关键字个数至少为(2/3)/M，即块的最低使用率为2/3，而B+树的块的最低使用率为1/2

<img src="D:\NOTES\zattachment\image-20231128120941027.png" alt="image-20231128120941027" style="zoom:80%;" />



# 图

线性表中元素关系是一对一，树中元素关系是一对多，那么当需要表示多对多关系时，引入图的概念

==图==是每个节点有零个或多个相邻元素的数据结构，两个节点相连称为边

相关概念：

- 顶点（vertex）：就是一个节点
- 路径：一个节点到另一个节点的到达方法
- 无向图：没有箭头标记方向的图
- 有向图：有箭头标记方向的图
- 带权图：边上带有权值的图，也叫网



表示方式

邻接矩阵

邻接矩阵是表示图中顶点之间相邻关系的矩阵，对n个顶点的图来说，矩阵的行、列表示的是各个节点

<img src="D:\NOTES\zattachment\image-20231128122039780.png" alt="image-20231128122039780" style="zoom:80%;" />



邻接表

邻接矩阵会为每个顶点分配n个边的存储空间，而很多边是不存在的，造成很多空间上的浪费

可以用邻接表只存储有关系之间的节点，邻接表由数组和链表组成

<img src="D:\NOTES\zattachment\image-20231128122505192.png" alt="image-20231128122505192" style="zoom:67%;" />





## 图的遍历

### 深度优先遍历

图的==深度优先遍历==（Depth First Search），优先往纵向挖掘深入，而不是而不是对一个节点的所有邻接节点横向访问

1. 访问从初始节点开始，再访问第一个邻接节点，以此往复
2. 如果节点被访问，则访问其第一个邻接节点
3. 如果该节点不存在，则从前一个节点的第二个邻接节点开始



### 广度优先遍历





























