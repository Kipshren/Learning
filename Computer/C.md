# Chaper1_最简单的程序
```cpp
#include<stdio.h>
int main(void){
	printf("Hello,World!");
	return 0;
}
```


# Chaper2_数据类型
## 基本数据类型
1. ***整数***
- 整型 int--4字节
- 短整型 short int--2字节
- 长整型 long int--8字节

2. ***浮点数***
- 单精度 float--4字节
- 双精度 double--8字节
- 表示：
	- 浮点数：double a = 1.14
	- 科学计数法：double b = 1.23e2 (123)

3. ***字符***
字符型 char--1字节，以ASC II码形式存储子啊存储单元

## 复合数据类型
1. ***结构体***
为什么需要结构体：为了表示一些复杂的事物，而普通的结构类型无法满足需求
定义：把一些基本的数据类型结合在一起，组成一个新的数据类型，这个数据类型称为结构体
结构体的表示：
```c
//方式一
structure student{// structure + 新类型名字
int age;
float score;
}
//方式二
struct student{
int age;
float score;
}st;  //直接定义一个类型为student的名为st的变量
//方式三
struct{
int age;
float score;
}st3;    
```

结构体变量的赋值和初始化：
```c
//方式一初始化
struct student st={19,66.6,'F'};
//方式二初始化
struct student st;
st.age=10;    //定义外面只能单个定义
st.score=88;
st.sex= 'F';
printf("%d %f %c\n",st.age,st.score,st.gender);
scanf("%d %f %c\n",&st.age,&st.score,&st.gender);
//元素是字符串的初始化
struct student st={"i love china"};
strcpy(st.str,"i love china");//字符串要不在定义时赋值，要不然在外面只能用strcpy赋值
```

取出结构体中的每一个成员：
```c
struct student st={19,66.6,'F'};
struct student *pst=&st;//注意指针变量的定义也要相同的数据类型
//方式一   结构体变量名.成员名
st.age=10;
//方式二   指针变量名->成员名
pst->age=88;
```

***结构体发送地址还是发送内容***
指针的优点: 快速的传递数据 ； 耗用内存少 ；执行速度快 //因为只用发送地址，占用字节数少
缺点:在函数中可能会改变输出值，可以用const修饰，只会传输地址不会改变内容

***结构体变量的运算***
对每个成员可以像普通变量一样
```c
student2.score=student1.score;
sum=student1.score+student2.score;
student2.score++;
student 1 = student 2//同类的结构体可以赋值
```

***结构体数组***
`struct 结构体名 数组名[数组长度]`
```c
 struct  person{
	char name;
	int num;
 }leader[3] ={"xia",0,"zhang",0,"zhou",0};
```

***结构体指针***
```c
struct student st;   //指针变量的类型一定要和指向变量的类型相同
struct student *p;  
p=&st;    //将st的起始地址赋给指针变量p
//(*p).name等价st.name等价p->name
```

***链表***

数组: 优点:存取速度快 缺点: 需要分配连续的很大的空间； 插入或删除元素的效率很低； 
链表 : 专业术语 
1.头结点:头结点就是首节点前面的那个节点； 头结点的数据类型与首节点的一模一样； 头结点不存放有效数据； 设置目的是为了方便对链表的操作。 
2.头指针:存放头结点地址的指针变量 
3.尾结点:最后一个节点，指针里面一般为null空 
4.首节点:存放第一有效数据的节点 
5.尾节点:存放最后一个有效数据的节点

确定一个指针需要一个参数：头指针 优点：插入删除元素效率高 ; 不需要一个连续的很大的内存; 缺点：查找某个位置的元素效率低
```c
struct student{
	int num;     //元素
	float score;
	struct student*next;  //指针
};
```


2. ***枚举***
定义：把一事物所有可能的取值一一列举出来
枚举的表示
`enum Weekday{Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday};`
枚举的本质是一个符号常量集，Monday本质默认是0，Tuesday是1。也可以对Monday = 4赋值，那么Tuesday是5，依次往后，而且都是枚举常量，不能赋值
```c
enum Weekday Day =Wednesday;
printf("%d",Day); //输出：2   只能赋在枚举里面的值
```


3. ***共用体***
定义：把多个不同数据类型的变量放在同一地址的内存单元，就是一**个数据的多种表现类型**
`union 共用体名  {成员列表}变量名;`
```c
union data{
	int i;
	char c;
}a,b,c;
```

共用体的数据长度：取多个数据类型中最长的。
int4字节，char1字节，那么data的长度为4字节

共同体的初始化和引用
```c
union data
{
	int i;
	char ch;
	float f;
}a;
a.i=97//只能赋给其中一个值，若再加上a.ch=是错误的。不跟结构体一样可以给每个元素都赋值，共用体只能共用一个值
```



## 强制转换数据类型
(数据类型) 原始数据
把数据类型强制转化为前面的数据类型
```c
int a = (int)6.6; //6
```

## 自定义数据类型
用typedef指定新的类型名来代替已有的类型名：
将变量名换成类型名，前面加上typedef，即声明了新类型名代表原来的类型
```c
//定义基本数据类型
typedef int Integer;
int a,b; 
Integer a,b;//等价于上面的int定义
//定义复合数据类型
typedef struct{
	int age;
	char name[10];
}Person; //定义了一个新类型名Person
Person p1; //定义了一个Person类型的p1变量
//定义数组
typedef int Num[100];//定义了一个新类型名Num、
Num a; //定义了一个名为a的Num数组
//定义指针
typedef char* String//定义了一个新类型String
String p,s[10];[//定义p为字符指针变量,s为字符指针变量
```


## 输入和输出
1. ***输出***
printf("xxxx")将引号中的内容原封不动输出到屏幕，除了换行符
```c
//只输出内容
printf("xxxx");
//输出变量
printf("%d,%f ,%s", i , j , str );
//输出换行符
printf("\n");
```

*输出控制符*：变量以什么形式输出
- int--%d
- long ing--%ld
- char--%c
- float--%f
- double--%lf
- 十六进制--%(#)x/X
- 八进制--%o
- 字符串--%s

2. ***输入***
scanf("输入控制符"，地址) 接收键盘输入的值
```c
//输入一个变量i的值
scanf("%d",&i);
//输入数组a的值
scanf("%d",a);
```
**注**：必须原封不动输入引号里面的内容，所以尽量不要使用非输入控制符，尤其是\\n

## 变量
变量：变量是内存中的一段存储空间
定义变量 i (int i)：就是请求一个称为 i 的内存空间，空间里面放的只能是int类型
注意事项：**如果定义变量后没有赋值，则变量里面是个随机值**，不会像其他语言赋0

# Chaper3_数组
数组(array)：内存中占有一系列连续的存储空间，\[]里面只能用整数表明有几个元素。
**注意事项**：a\[n]是错误写法，\[]里面元素个数必须准确确定

## 一维数组
int a\[3]={1,2,3}：
- 解释：在内存空间的一段存储单元中创建一个名字为a的数组，且这个数组只含有3个元素，即开辟了3个存储单元
- 下标：内存里一段连续的数组中，第一个元素从0开始，依次往后，即有a\[0]\==1,a\[1]\==2,a\[2]\==3
- 原理：a数组名表示数组第一个元素的地址(即数组的首地址)，a等价于&a\[0]

1. ***数组的定义***
```c
//规定数组元素个数
int a[3]={1,2,3};
//只定义个数组，数组个数不确定
char str[] ="xia";
```

2. ***数组的初始化***
```c
//完全初始化
int a[5]={1,2,3,4,5};
//不完全初始化
int a[5]={1,2,3}; //其他元素自动为0(int)，null(char)...
//不初始化
int a[5]; //所有元素都是垃圾值
//清零
int a[5] = {0};
```
**注意事项**：只有在定义数组的同时才能整体赋值，其他情况下赋值都是错误的。定义情况外，\[]里数字都是表示它的位置(即下标)

3. ***一维数组的遍历***
**数组的输出一定要遍历**
```c
int a[4]={1,2,3,4};
for(i=0;i<sizeof(a)/sizeof(int);i++){
	printf("%d\n",a[i]);
}
```

## 二维数组
 int a \[3]\[4]={1,2,3,4,5,6,7,8,9,10,11,12}：
 - 解释：定义了一个二维数组a，表明数组a有i行j列，一共有i\*j个元素
 - 下标：跟一维数组的方法一样，a\[0]\[0]是第一行第一个元素，a\[1]\[0]是第二行第一个元素
 - 等价：inta\[3]\[4]={{1,2,3,4},{5,6,7,8},{9,10,11,12}};
 - 原理：
```c
a         //0x105d7ffdf0
&a        //0x105d7ffdf0
a[0]      //0x105d7ffdf0
&a[0]     //0x105d7ffdf0
a[1]      //0x105d7ffe00
&a[0][0]  //0x105d7ffdf0
a[0][0]   //1
a[1][0]   //5
```
有确定的元素位置(即有两个坐标)表示的是元素内容，其他的都表示地址。
	数组首地址=第一行地址=第一个元素地址
	行地址=首行元素地址

1. ***二维数组的遍历***
```c
int a[3][4]={1,2,3,4,5,6,7,8,9,10,11,12};
for(i=0;i<3;i++){
	for(j=0;j<4;j++){
		printf("%d",a[i][j]);
	}
}
```

## 字符数组
定义和初始化都跟其他类型数组一样，只是字符需要加 ' '
```c
//字符
char a[] ={'a',' ','c'};
//字符串
char str[] ="xia";
//字符串结束标志:\0  (系统会自动在字符串最后一个字符后加 \0 )
```
注意：
- 字符串有效长度为\\0前字符长度，字符串数组长度的有效长度要加上\\0
- ' \\0 ' 在ASC II码中为 0 ，所以也可以用 0 表示 ' \\0 '

1. ***输入和输出***
1) *printf和scanf* 
- %c按字符输入输出
- %s按字符串输入输出
```c
//输出单个字符
char a[]={'a','b','c'};
printf("%c",a[0]); //必须指定是哪个元素
//输出字符串
char a[]="xia yi lang";
printf("%s",a); //输出字符串用首地址
```

2) *puts和gets*
存在<stdio.h>库中
`puts/gets(首地址)`  输出输入整个字符串
`puts(下标地址)`   输出下标及后面的字符
```c
//输出
char str1[] ="xia";
puts(str1);
puts("xia");//两个输出结果相同
puts(&str1[1]);//ia 输出第i下标后的字符
//输入
char str2[10];
gets(str2);
```
**gets和scanf的区别：**
gets以回车结束
scanf以回车和**空格**结束
```c
str[10];
//输入: i love u
gets(str) //接收：i love u
scanf("%s",str) //接收：i  ，空格后面全都没有
```

2. ***字符串函数***
1) *strlen函数*
检测字符串的长度，存储在< string.h >库中
`strlen(首地址)`     检测整个字符串的长度
`strlen(下标地址)`  检测下标及后面字符的长度
```c
str[] ="0123456789"
strlen(str) //输出：10
strlen(&str[5]) //输出：5  (5~9)
```

举个栗子：
```c
str1="0123\0456789"           //strlen(str1)=9,strlen(&str[5])=4
//\045是转义字符
str2={'A','0','B','C','0','D'}//strlen(str2)=12
str3="\t\v\\\0will\n"         //strlen(str3)=3
str4="\x60\082\n"             //strlen(str4)=1
```

2) *strcpy函数*
复制字符串，存储在< string.h >库中
`strcpy(str1,str2)` 将str2复制到str1中  （str1中有内容则会覆盖）
```c
 str1="iloveu",str2"yes";
 strcpy(str1,str2);   //str1=yes
 strcpy(str1,"china");//str1=china
```
注意：
- strcpy会同时将后面的\\0复制进去，即前6个元素为china\\0，后面剩余的存储空间要减去6个
- 数组间的复制不能用赋值语句，因为数组名是一个指针变量
- 可以用`strncpy(str1,str2,2)`指定str2的前2个字符复制到str1中，个数小于str1长度
- 字符串一定不能直接赋给变量，因为字符串返回的是首地址，而变量是数据

3) *strcmp函数*
比较两个字符串大小，存储在<string.h>库中
`strcmp(str1,str2)`  将两字符串自左至右逐个字符比较（以ASCII码大小比较），直到遇到不同字符或遇到\\0为止
- str1 == str2 返回0
- str1 > str2 返回正整数
- str1 < str2 返回负整数
```c
strcmp("abcd", "abCD");//返回正整数
strcmp("1234","12345");//返回负整数
strcmp("hello","hello");//返回0
```

举个例子：判断密码是否输入正确
```c
if(strcmp(password,"daministrator")==0) //输入正确就执行下一步
```
注意：
- stricmp在比较字符时不区分大小写，而strcmp区分大小写
- `strncmp(str1，str2，n)`  比较前n个字符

4) *strcat函数*
连接两个字符串，存储在<string.h>库中 (catenate)
`strcat(str1，str2) `     把字str2连接到str1后面
注意：函数的**返回值是str1的地址**
```c
str1[20] ="12345",str2[] ="6789";
strcat(str1,str2);
printf("%s",str1); //123456789
```


# Chaper5_运算符
## 算术运算符
五种：`+ - * / %` 
其他：`++自增  --自减`  但只能变量使用
**注意事项：**
- i++ 先用后加     ++i是先加后用
- 除法/ 如果左右都为整数，执行整数除法。而只要有浮点数执行的就是浮点数除法
- 除了 取余% 之外，其他几个都可以作用于整数和浮点数
- % 左右必须为整数，返回的是整除之后的余数

## 关系运算符
`>  <  >=  <=  ==  !=`
**注意事项：** 一定要注意 == 和赋值=区别 

## 逻辑运算符
`&&  ||  !`
1. ***逻辑与 &&***
表达式1 && 表达式2
**一假全假，全真为真**：当表达式1、2都为真时，整个表达式为真。若左边为假，右边就不会执行

2. ***逻辑或||***
表达式1 || 表达式2
**一真为真， 全假为假**：当表达式1、2一个为真时，整个表达式为真。若左边为真，右边就不会执行

3. ***逻辑非!***
!表达式
**真取假  假取真**

## 位运算符
`& | ^ << >>`
1. ***按位与***
2. ***按位或***
3. ***按位异或***
4. ***右移***
5. ***左移***

## 赋值运算符
`+= -= *= /= %= >>= <<= &= |= ^=`
这些运算符可以达到复合的效果
x += 10 等价于  x=x+10

## 三目运算符
`表达式1?表达式2:表达式3`
表达式1为真->表达式2执行
表达式1为假->表达式3执行

## 逗号表达式
`表达式1,表达式2,表达式3,...,表达式`
逗号表达式，就是用逗号隔开的多个表达式。表达式从左向右依次执行，整个表达式的结果是最后一个表达式的结果。

## sizeof运算符
`sizeof(变量/数据类型)`
获取所占字节数

## 运算符优先级
![[Pasted image 20230707103516.png|477]]

上表中可以总结出如下规律：
1. 结合方向只有三个是从右往左，其余都是从左往右。
2. 所有双目运算符中只有赋值运算符的结合方向是从右往左。
3. 另外两个从右往左结合的运算符也很好记，因为它们很特殊：一个是单目运算符，一个是三目运算符。
4. C语言中有且只有一个三目运算符。
5. 逗号运算符的优先级最低，要记住。
6. 此外要记住，对于优先级：算术运算符 > 关系运算符 > 逻辑运算符 > 赋值运算符。逻辑运算符中“逻辑非 !”除外。


# Chaper6_流程控制
顺序：默认从上到下，从右到左

## if语句
```c
if(表达式1){ 语句A;} //表达式为真就执行
elseif(表达式2){ 语句B;} 
else { 语句C;}
```
**注意**：if语句默认只控制一个语句A，若要控制两个以上的语句则需要用{}括起来

## switch语句
```c
switch(变量){
case '值1':表达式1 break;  //情况一
case '值2':表达式2 break;  //情况二
case '值3':表达式3 break;  //情况三
default: 表达式4 break;    //其他情况
}
```
**注意**：case是一个入口，一个case没有break的话，会一直执行以后的case里的语句，直到碰到break才停止运行

## 循环语句
1. ***for语句***
`for( 1 ; 2 ; 3 ){语句A}`
执行顺序： 先执行1，然后判断2是不是真，为真就执行语句A，执行完A后执行3。一个循环完毕。第二次循环直接看 2 是否为真
```c
for(i=0;i<5;i++){
int a[5]={1,2,3,4,5};
printf("%d",a[i]);--12345
printf("%d",i)--5 //注意:循环变量最后输出的是不满足条件的值
}
```

2. ***while语句***
`while(表达式){语句A}`
表达式为真就执行语句A

3. ***do...while语句***
`do{语句A}while(表达式)`
先执行语句A一次，然后判断表达式是否为真。为真就再执行语句A
与while的区别：do...while中语句A一定会执行一遍

## 语句的终止
1. ***break***
 用来终止循环和终止switch。**不能终止if**，除非if属于循环内的一个子句
 **注意**：在多层循环，只能终止最近的那个循环
```c
 for(i=0;i<3;i++){
     if(3>2)
     break;//break终止了整个循环
     printf("嘿嘿\n");//永远不会输出
 }
```

2. ***continue*** 
跳过本次循环的语句，直接去判断是否进入下一个循环

3. ***return*** 
终止函数的执行，向主调函数返回表达式的值。如果表达式为空，则只终止函数，没有返回值

# Chaper7_函数
作用：一个工具，可以解决大量同类型的问题 
为什么用函数：避免重复性操作；有利于程序的模块化
定义一个函数：`函数返回值 函数名(函数形参){执行体}`
函数的声明：`函数返回值 函数名(函数形参);`
注意：**声明是一个语句，一定要加分号 ;**
什么时候需要函数的声明：当函数调用在函数定义之前，则必须加函数前置声明。且在其他函数中运用时也要声明。

**注意**：
- 形参不改变主函数中变量值
- 返回值以函数名前的数据类型为准  `int void return10.5`最终返回10


1. ***实参和形参***
```c
void main{
f(3,4);// 3,4是实参
}
void f(int i,int j){ //i,j是形参
i++;j++;  
}
```
 - 形参：指函数名后括号中的变量，因为形式参数只有在函数被调用的过程中才实例化
 - 实参：真实传给函数的参数
原理：函数是内存空间中新创建的一段程序，会生成新的变量来接收传入的参数，那么这个变量和表示实参的变量是没有关系的。那么改变函数的参数值，并不会影响主函数中的变量值

注意： **形参和实参必须一一对应，数据类型必须一致**

2. ***递归***
函数的递归调用：函数自己调用自己
注：只递不归会导致程序崩溃，要用适当的条件终止递归 ( 调用函数时，会在内存占用一些叫栈的内存空间。调用函数时，都必须放些数据到栈里。函数运行结束后，会释放数据。若只递不归，栈会被数据填满-----栈溢出 )

```c
//求1+2+3+4+5+...+100=
int f(x){
if(x>0)
	a=x+f(x-1);//递归
return a;
}
printf("%d",f(100))  
```


# Chaper8_指针
指针：**指针就是地址**，内存单元的编号
指针的重要性：表示一些复杂的数据结构；快速的传递数据，减少了内存的耗用；使函数返回一个以上的值; ​ 能方便处理字符串；是理解面向对象语言中引用的基础。
指针变量：存放地址的变量
```c
int i=3;
int *p;   //定义一个指针变量,p是变量名,int*表示p存放的是int类型的变量地址
p=&i;     //把i的地址给p，因此p里含i的地址，p指向i
*p==3==i; //*指针变量名, *p 表明以p的内容为地址的变量m,*是与p在一起
```
图解：

运用指针交换变量
```c
void switch(int*i,int*j){
	int temp;
	temp=*i;
	*i=*j;
	*j=temp;
}
int main(void){
int a, b;
a=5;
b=3;
switch(&a, &b);
printf("a = %d , b = %d", a, b);//输出：a=3, b=5
}
```

***指针和数组***
一维数组
一维数组名是指针变量，里面存放的a是第一个元素的地址（首地址）
下标和指针的关系：
```c
int *p,a[5];
p=a;
// *p 等价于a[0]   *(p+i)等价于a[i]
```
确定一个一位数组需要几个参数：数组首地址和长度

数组首地址和长度
```c
 void array(int *array, intlen)
 {
     int i;
     for(i=0; i<len; i++)
     printf("%d\t", *(array+i));//用array[i]也可以
 }
 int main(void)
 {
     inta[5] ={1, 2, 3, 4, 5};
     array(a, 5);
 }
```

***指针变量的运算***
地址不能相加、乘、除。只有当两个指针变量指向的是同一块连续空间的不同存储单元，那么这两个可以相减，表示存储单元之间的距离。可以类比门牌号。
```c
int a[5];
int *q,*p;
q=&a[0],p=&a[3];
p-q //输出：3
```

***指针和字符串***
初始化和引用：
```c
char *str="i love china";   //str指针变量里存放的是字符数组的首地址
char str[] ="i love china";只有这两种方式存储字符串
```
 C语言对字符串常量都是按字符数组处理的，在内存中开辟了一个字符数组用来存储字符串常量，但这个数组没数组名，只能通过指针变量来引用
 
输出：
- printf("%s",str);     输出字符串只能用地址&str\[2]或str+2
- printf("%c",a\[2]);  输出字符只能精确到哪一个变量a\[1]或者*(a+1)
   
***指针变量复制字符串***
``` c
char a[] ="i am a student.", b[20];
for(i=0; *(a+i) !='0';i++)
	*(b+i) =*(a+i);
	*(b+i) ='\0';//最后的 i 是与 a 的终止第几个一样的
```

***指针数组***
一个数组里面的每一个元素都存放着一个地址
指针数组`int *p[4]`
\[\]优先度高于\*，p先和\[]结合表明这是一个数组，p再与\*结合表明这个数组是指针类型的，int每个数组元素都可指向一个整型变量

***二维数组***
```c
 int a[3][4];
 a        //代表数组首行地址，一般用a[0][0]的地址表示
 &a       //代表整个数组的地址，一般用a[0][0]地址表示
 a[i]     //代表了第i行起始元素的地址(网上说是代表了第i行的地址
 &a[i]    //代表了第i行的地址，一般用a[i][0]的地址表示
 a[i]+j   //代表了第i行第j个元素地址,a[i]就是j==0的情况
 a[i][j]  //代表了第i行第j个元素
 &a[i][j] //代表了第i行第j个元素的地址
 *a       //代表数组a首元素地址也就是a[0]或者&a[0][0]，指向一个指针变量，指针变量指向整型数组
 *(a+i)   //代表了第i行首元素的地址,*a是i=0的情况
 *(a+i)+j //代表了第i行j个元素的地址
 **a      //代表a的首元素的值也就是a[0][0]
 *(*(a+i)+j)  //代表了第i行第j个元素

 int a[][4]//可以省略行的元素，但列不能省略
 int a[3][4];
 int(*p)[4];
 p=a;
```

***指针和函数***
函数的指针：存放函数地址的指针变量
在程序中定义了一段函数，在编译时会把函数的源代码转换为可执行代码并分配一段存储空间。这段内存空间有一个起始地址，也称函数的入口地址，每次调用函数时都从该地址入口开始执行此段代码。**函数名代表着函数的起始地址**，每次调用函数从函数名得到起始地址
```c
int max(int x, int y);
int(*p)(int x,int y) //*p表示的是指针变量，(int x,int y)表示的是p变量指向的是一个函数，也表示出了这个函数的形参是什么，可以通过形参和函数进行对应
p=max;  //将函数max的入口地址给指针变量p
c=(*p)(a,b)等价于c=p(a,b)等价于c=max(a,b)
 //因为max存放的是函数首地址，p也存放的是函数首地址，可以只换函数名
```
注意：如果加上了 * ,必须把 (\*P) 括起来，表明这个变量是指针变量


函数的指针作为函数的参数
 返回值 函数名(指针变量类型(\*B函数名)(B函数形参))
     形参的(\*p)必须括起来，表明这是一个指针变量 
 ```c
 void fun(int(*x1)(int),int((*x2)(int,int)) // 即在fun函数中调用f1函数和f2函数{
	int a,b,i=3,j=5;
	a=x1(i);  //x1中保存着f1函数的地址
	b=x2(i,j);  //x2中保存着f2函数的地址
 }
 void fun(f1,f2);
```
 传输其他函数的头地址到函数里，形参用指针变量，而且函数的指针变量必须写上函数的形参，以表示是哪个函数


返回指针的函数
`类型名 *函数名（参数）`
`int *a(intx, inty)`
()优先度比\*高，所以a先和(intx, inty)结合，所以a(intx, inty)是一个函数, \*表示此函数的返回值是指针，前面的int表示返回的指针指向整型变量
 - int\*a(intx,inty)     函数
 - int(\*a)(intx,inty)   指针变量
 **看名字和谁结合，先和\*结合就是变量，先和()结合就是函数**

多级指针
```c
int i=10;
int *p=&i;
int **q=&p;
int ***r=&q;
***r=10;  //*r =& q    **r = &p
```


# Chaper9_文件输入输出
## 什么是文件
文件：一般指存储在外部介质上的数据的集合

1. ***流(数据流)***
输入输出信息的过程，信息如流水一样从一端流向另一端，因此称之为流（数据流）。流表示信息从源到目的端的流动。数据从文件流向计算机内存为输入流。数据从计算机流向文件为输出流。

2. ***文件的分类***
数据文件可以分为ASCII文件（文本文件）和二进制文件。
数据在磁盘上存储形式，字符以ASCII形式存储，数值型数据既可以用ASCII形式存储也可以用二进制形式存储

3. ***文件缓冲区***
内存向磁盘中输出的数据需要先送到内存中的缓冲区，在缓冲区装满之后，才一起送到磁盘中。从磁盘中想计算机输入数据也是先把数据放到缓冲区，然后再逐个的从缓冲区把数据送入程序数据区，输入输出共用一个缓冲区。

4. ***文件类型指针***
每个被使用的文件都在内存中开辟一个相应的文件信息区，用来存放文件你的有关信息（文件的名字、文件状态、文件的当前位置等）。这些信息保存在一个结构体中。如stdio.h中文件类型声明如下
```c
type struct
{
    short level;        //缓冲区满或空的程度
    unsigned flags;     //文件描述状态
    char fd;            //文件描述符
    unsigned char hold; //如缓存区为内容不读取字符
    short bsize;        //缓冲区的大小
    unsigned char *buffer; //数据缓冲区的位置
    unsigned char *curp;   //文件位置标记当前指针当前的指向
    unsigned istemp;       //临时文件指示器
    short token;           //用于有效性检查
}FILE;
//定义一个指针变量
FILE *fp; //定义fp是指向FILE类型的指针变量。可以是fp指向文件的信息区，通过文件信息区的信息就能够访问文件
```

## 文件的打开和关闭
- 打开：为文件建立相应的信息区（用来存放文件相关信息）和文件缓冲区（用来暂时存放输入输出的数据）。一般在打开文件的同时，一般都制定一个指针变量指向文件，这样就可以对文件进行读写了。
- 关闭：撤销文件信息区和文件缓冲区，使文件指针不再指向该文件，就无法对文件进行读写了

1. ***fopen函数打开文件***
`fopen("文件名",访问文件的方式)`
![[Pasted image 20230708204324.png]]
```c
FILE *fp; //定义一个指向文件的指针变量
fp=fopen("he","r")//fopen函数的返回值是指向该文件的指针即该文件的信息区的起始地址。通常将fopen的返回值赋给一个指向文件的指针变量。
```

2. ***fclose函数关闭数据文件***
`fclose(文件指针)`
如果不关闭文件就结束程序运行将会丢失数据，因为，在向文件写入数据时，先将数据输出到缓冲区，缓冲区放满之后才正式输出给文件，如果当数据还在缓冲区的时关闭程序，就可能使缓冲的数据丢失。**用fclose关闭文件，可以把缓冲区的数据输出到磁盘文件，再撤销文件信息区。**

## 读写文件
1. ***文件的写入***
1) *对文件输出一个字符*
`fputc(字符,文件指针fp)`   把字符写入到fp所指的文件中
2) *对文件输出一个字符串*
`fputs(字符串,文件指针fp)`  把fp所指向的字符串写入到指针变量所指的文件中
```c
#include <stdio.h>
int main()
{
	FILE *fp;
	char str[4][10]; 
	int i;
	for(i=0;i<4;i++){
		gets(str[i]);    //把单词写入字符串str中 
	}
	fp = fopen("E:\\CC\\one.dat","w");   //打开磁盘文件，我是要在E盘中CC文件夹的中写入，运行之后就会发现你的硬盘里有了一个文件 
	for(i=0;i<4;i++){
		fputs(str[i],fp);fputs("\n",fp);   //在磁盘文件写入一个字符串，然后输出一个和换行符
		printf("%s\n",str[i]);              //在屏幕上显示 
	} 
	fclose(fp);   //关闭文件 
	return 0;
} 
```

2. ***文件的读取***
1) *对文件读取字符*
`fgetc(文件指针fp) `从fp指向的文件中读取一个字符 
2) *对文件读取字符串*
`fgets(数组,读取长度n,文件指针fp)` 从fp指向的文件读取长度为(n-1)的字符串存入数组中并在最后加一个字符 '\\0';
```c
//现在把刚刚存入的四个字符串取出来
#include <stdio.h>
int main(){
	FILE *fp;
	char str[4][10];        
	int i;
	fp = fopen("E:\\CC\\one.dat","r");  //打开上面保存的文件 
	for(i = 0;i<4;i++){
		fgets(str[i],10,fp);       //读取10个字节文件指针指向的文件中的数据，存入数组中 
		printf("%s\n",str[i]);
	}
	fclose(fp);   //关闭文件 
	return 0;
} 
```


# Chaper10_作用域
作用域是程序中用来定义变量存在的区域，超过这个区域的变量就不能被访问了。C语言中有两个区域可以用来声明变量：
1. ***在函数或块内部的局部变量***
在某个函数的内部声明的变量称为局部变量。这些变量只能被改申明的函数使用。局部变量在函数外是不能使用的。

2. ***在所有函数外部的全局变量***
全局变量是定义在函数的外部，一般都是定义在程序的顶部。全局变量在整个函数运行的时候都是有效的，在任意的函数的内部都能访问很调用全局变量。
注意：在程序中，局部变量名和全局变量名是可以相同的，但是在函数内，如果两个名字一样的话，会用局部变量的值，全局变量不会被使用。
```c
int a =20;
int main(){
	int a= 30;
	int b= 10;
	printf("%d",a);//输出：30  局部变量
}
void f(){
	printf("%d",a);//输出：20  全局变量
	//b是局部变量，不能在f()中使用
}
```


# Chaper11_define预定义
## 定义标识符
使用#define可以用来定义标识符，所谓标识符可以简单理解为一个能够表示一定内容的符号
`#define 标识符 内容`
```c
#define MAX 100 //将MAX这个标识符和100这个数字关联起来
#define REG register //为register这个关键字，创建一个简短的名字REG
printf("%d",MAX);//输出：100
```
由于预先对标识符进行了定义，在程序的预处理阶段， 编译器会将所有定义的**标识符替换**成相应的内容并生成 .i 文件

## 定义宏
define机制包括了一个规定，允许把参数替换到文本中，这种实现通常称为宏（macro）或定义宏 (define macro)。**宏就是替换**。
义宏可分为两种
1. 一种是不带参数的宏定义，这也就是第1小节提到的使用#define定义标识符
2. 第二种是带参数的宏定义，其定义格式如下
`#define  宏名(参数表) 内容`

```c
#define ADD(a,b) (a+b) //定义了一个名为ADD的宏 ，宏有两个参数a和b，这个宏所要实现的功能是将a和b相加
int a=10,b=20;
int sum=ADD(a,b);
printf("%d",sum);//输出30
//宏定义的程序中，预处理器会将ADD(a,b)替换成(a+b)，宏定义是将(a+b)这样一个求和操作重新命名并置于main函数中
```
注意：参数列表的左括号必须与宏名紧邻， 如果两者之间有任何空白存在，参数列表就会被解释为stuff的一部分 

```c
#define SQUAREA(x) (x * x)
#define SQUAREB(x) ((x) * (x)) 
int main(){
	int ansa = SQUAREA(3 + 1);//输出：7   3+1*3+1
	int ansb = SQUAREB(3 + 1);//输出：16  (3+1)*(3+1)
}
//因此，所有用于对数值表达式进行求值的宏定义都应该用这种方式加上括号，避免在使用宏时由于参数中的操作符或邻近操作符之间不可预料的相互作用
```

## 替换规则
在程序中扩展#define定义符号和宏时，需要涉及几个步骤
1. 在调用宏时，首先对参数进行检查，看看是否包含任何由#define定义的符号。如果是，它们首先被替换 
2. 替换文本随后被插入到程序中原来文本的位置。对于宏，参数名被他们的值所替换
3. 最后，再次对结果文件进行扫描，看看它是否包含任何由#define定义的符号。如果是，就重复上述处理过程

**注意** ：
1. 宏参数和#define 定义中可以出现其他#define定义的符号。但是对于宏，不能出现递归
2.  当预处理器搜索#define定义的符号的时候，字符串常量的内容并不被搜索

## 宏和函数对比
一般来讲函数的宏的使用语法很相似。所以语言本身没法帮我们区分二者。那我们平时的一个习惯是：把宏名全部大写，函数名不要全部大写

***宏相对函数的优点***：
1. 调用函数的时间可能比实际执行这个程序工作的时间更多。**所以宏比函数在程序的规模和速度方面更胜一筹**
2. 更为重要的是函数的参数必须声明为特定的类型。  所以函数只能在类型合适的表达式上使用。反之这个宏怎可以适用于整形、长整型、浮点型等可以用于>来比较的类型。**宏是类型无关的**
3. 宏有时候可以做函数做不到的事情。比如：宏的参数可以出现数据类型，但是函数不行
```c
#define MALLOC(num, type) (type *)malloc(num * sizeof(type))
MALLOC(10, int);  //数据类型作为参数
//预处理器替换之后：
(int*)malloc(10 * sizeof(int));
```
***宏的缺点***：
1. 每次使用宏的时候，一份宏定义的代码将插入到程序中。除非宏比较短，否则可能大幅度增加程序的长度
2. 宏是没法调试的
3. 宏由于类型无关，也就不够严谨
4. 宏可能会带来运算符优先级的问题，导致程容易出现错

|   |   |   |
|---|---|---|
|属性|\#define定义宏|函数|
|代码长度|每次使用时，宏代码都会被插入到程序中。除了非常小的宏之外，程序的长度会大幅度增长|函数代码只出现于一个地方；每次使用这个函数时，都调用那个地方的同一份代码|
|执行速度|更快|存在函数的调用和返回的额外开销，所以相对慢一些|
|操作符优先级|宏参数的求值是在所有周围表达式的上下文环境里，除非加上括号，否则邻近操作符的优先级可能会产生不可预料的后果，所以建议宏在书写的时候多些括号|函数参数只在函数调用的时候求值一次，它的结果值传递给函数。表达式的求值结果更容易预测|
|带有副作用的参数|参数可能被替换到宏体中的多个位置，所以带有副作用的参数求值可能会产生不可预料的结果|函数参数只在传参的时候求值一次，结果更容易控制|
|参数类型|宏的参数与类型无关，只要对参数的操作是合法的，它就可以使用于任何参数类型|函数的参数是与类型有关的，如果参数的类型不同，就需要不同的函数，即使他们执行的任务是不同的|
|调试|宏是不方便调试的|函数是可以逐语句调试的|
|递归|宏是不能递归的|函数是可以递归的|


# Chaper12_动态数组
动态数组是相对于静态数组而言的，从“动”字可以看出它的灵活性。静态数组的长度是预先定义好的，在整个程序中，一旦给定数组大小后就无法改变。而动态数组则不然，它可以根据程序需要重新指定数组大小。动态数组的内存空间是由堆动态分配的，通过执行代码为其分配存储空间，只有程序执行到分配语句时，才为其分配存储空间。

 ***动态数组和一般数组（静态数组）的区别***

- 静态数组：创建非常方便，使用完也无需释放，引用起来也简单，但是创建后无法改变数组大小是其致命的弱点。
- 动态数组：创建麻烦，使用完必须由程序员自己释放，否则会引起内存泄露，但是其使用非常灵活，能根据程序需要动态分配大小。

***动态数组的创建和使用***

在创建动态数组的过程中要遵循一个原则，那就是从外层向里层逐层创建，从里层向外层逐层释放。如果要创建一个N维的动态数组，那么要从第一维开始创建，直到第N维为止；而释放时与创建时相反，即从第N维开始释放，直到第一维为止。下面我们一起来看看一维动态数组和二维动态数组。

***一维动态数组***
`类型说明符* 数组名 = (类型说明符*)malloc(数组长度*sizeof(类型说明符))`
```c
#include<stdio.h>
#include<stdlib.h>

int main() {
    int n; //用来接收要创建的一维动态数组的长度
    int *arr;
    printf("请输入所要创建的一维动态数组的长度:");
    scanf("%d", &n);
    if ((arr = (int *) malloc(sizeof(int) * n)) == NULL) { //使用malloc来动态分配内存
        printf("分配内存空间失败!\n");//如果内存分配失败，报错异常退出
        return -1;
    }
    for (int i = 0; i < n; i++) { //通过循环给数组赋值并在控制台进行打印
        arr[i] = i + 1;
        printf("%d\t", arr[i]);
    }
    free(arr); //释放内存空间

    return 0;
}
```

二维动态数组
```c
类型说明符** 数组名 = (类型说明符**)malloc(第一维长度*sizeof(类型说明符*)) 
for(int i=0;i<第一维长度;i++){ 
数组名[i]=(类型说明符*)malloc(第二维长度*sizeof(类型说明符)) 
}
```

```c
#include<stdio.h>
#include<stdlib.h>
int main() {
    int n1, n2;
    int **arr;
    printf("请输入所要创建的动态数组的第一维长度：");
    scanf("%d", &n1);
    printf("请输入所要创建的动态数组的第二维长度：");
    scanf("%d", &n2);

    if ((arr = (int **) malloc(n1 * sizeof(int *))) == NULL)//使用malloc给第一维分配内存
    {
        printf("分配内存空间失败!\n");//如果内存分配失败，报错异常退出
        return -1;
    }

    for (int i = 0; i < n1; i++) {
        if ((arr[i] = (int *) malloc(n2 * sizeof(int))) == NULL)//使用malloc给第二维分配内存
        {
            printf("分配内存空间失败!\n");//如果内存分配失败，报错异常退出
            return -1;
        }
    }
    for (int i = 0; i < n1; i++) { //通过循环给数组赋值并在控制台进行打印
        for (int j = 0; j < n2; j++) {
            arr[i][j] = i * n2 + j + 1;
            printf("%d\t", arr[i][j]);
        }
        printf("\n");
    }
    for (int i = 0; i < n1; i++) {
        free(arr[i]);//释放第二维
    }
    free(arr);//释放第一维

    return 0;
}
```




浮点数精度问题

float和double斗都不能保证可以把所有实数都准确的存储在计算机中，即有误差，所以循环中的整数变量不能定义为浮点型

float i =5 ; 可能 i = 4.99967

 有一个浮点型变量x，如何判断x的值是否为零

 if(|x-0.00000001|<=0.00000001)

   是零

 else

   不是零










