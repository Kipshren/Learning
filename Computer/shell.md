注释
- 单行注释： #
- 多行注释：:<

变量
运行shell时。会同时存在三种变量
1. 局部变量，在脚本中定义，仅在当前文件中有效
2. 环境变量，所有程序都能访问
3. shell变量，由shell程序设置的特殊变量
变量操作
- 创建变量：name="xia"(=两边不能有空格)
- 只能在函数体中使用的局部变量：local name="xia"
- 输出变量：$name 或 ${name} (更推荐)
- 只读变量： readonly name="xia"（不可被修改）
- 删除变量：unset name

**字符串**

拼接字符串
name='xia'" yilang"'wo shi'（"" '' 之间没有符号空格）

获取字符串长度
用${#}
${#name}

子串
echo ${name:1:4} 从下标1开始往后截取4个字符
echo ${name:2} 从下标2输出后面剩余的字符
echo ${name::2} 输出前2个字符

**数组**
- 定义数组：array=(i like u)小括号做边界，用空格分隔
- 单独定义数组的元素：array\[0]="xia"
- 输出数组：${array\[0]}
${array\[@]}（输出数组所有元素）
${#array}（输出数组元素个数）
${#array\[1]}（输出单个元素的长度）

**参数传递**
获取参数：
$0 执行文件名
$1 传入的第1个参数
数字可以依次往下

$#参数个数
$* 以单字符串显示所有向脚本传递的参数
$@ 与\$\*相同，但是使用时加引号，并在引号中返回每个参数
\$$ 脚本运行的当前进程号
$! 后台运行的最后一个进程ID
$? 显示最后命令的退出状态。只有0表示没有出错
$* 与 $@ 区别
-   相同点：都是引用所有参数。
-   不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）。

运算符

算术运算
- val=\`expr 2 + 3\`  每个都要加空格，其中\*要加\\转义
- val=$\[2+3]   不必添加空格
- val=$((2+3))   不必添加空格

数字关系运算符
只支持数字，不支持字符串，除非字符串的值都数字
|运算符|用处|
|----|----|
|-eq|相等，|
|-ne|不相等|
|-gt|大于|
|-lt|小于|
|-ge|大于等于|
|-le|小于等于|

字符串运算符
|运算法|用处|
|----|----|
|=|相等    \[str1 = str2]|
|!=|不相等    \[str1 != str2]|
|-z|长度为0   \[-z $str]|
|-n|长度不为0   \[-n $str]|
|$|不为空   \[\$str]|
布尔运算符
|运算法|用处|
|----|----|
|!|非运算，表达式为 true 则返回 false，否则返回 true。\[ ! false ] 返回 true|
|-o|或运算，有一个表达式为 true 则返回 true。\[ $a -lt 20 -o $b -gt 100 ] 返回 true|
|-a|与运算，两个表达式都为 true 才返回 true。\[ $a -lt 20 -a $b -gt 100 ] 返回 false|

文件运算符
|运算法|用处|
|----|----|
|-b file |检测文件是否是块设备文件，如果是，则返回 true。 \[ -b $file ] 返回 false。
|  -c file |检测文件是否是字符设备文件，如果是，则返回 true。 \[ -c $file ] 返回 false。
| -d file |检测文件是否是目录，如果是，则返回 true。 \[ -d $file ] 返回 false。
|  -f file|检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 \[ -f $file ] 返回 true。
|   -g file |检测文件是否设置了 SGID 位，如果是，则返回 true。 \[ -g $file ] 返回 false。
|  -k file |检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 \[ -k $file ] 返回 false。
| -p file |检测文件是否是有名管道，如果是，则返回 true。 \[ -p $file ] 返回 false。
|   -u file |检测文件是否设置了 SUID 位，如果是，则返回 true。 \[ -u $file ] 返回 false。
|   -r file |检测文件是否可读，如果是，则返回 true。 \[ -r $file ] 返回 true。
|  -w file |检测文件是否可写，如果是，则返回 true。 \[ -w $file ] 返回 true。
|  -x file |检测文件是否可执行，如果是，则返回 true。 \[ -x $file ] 返回 true。
| -s file |检测文件是否为空（文件大小是否大于0），不为空返回 true。 \[ -s $file ] 返回 true。
|   -e file |检测文件（包括目录）是否存在，如果是，则返回 true。 \[ -e $file ] 返回 true。

命令替换
命令替换与变量替换差不多，都是用来重组命令行的。先完成引号里的命令行，然后将其结果替换出来，再重组成新的命令行。

1.  \`ls /etc\` ： 反引号 （所有的unix系统都支持）
2.  $(ls /etc) ： $+() （部分unix系统不支持）  
    多个嵌套使用时，从内向外执行for file in \s /etc\ 或 for file in $(ls /etc) 循环中使用  
    \`dirname \$0\` 获取脚本文件所在的目录  
    path=$(cd \`dirname $0\`;pwd) ： 获取脚本当前所在目录，并且执行cd命令到达该目录，使用pwd获取路径并赋值到path变量

**逻辑判断**

1. \[] ： 中括号旁边和运算符两边必须添加空格 （可以使用，不推荐）
2. \[\[ ]]：中括号旁边和运算符两边必须添加空格 （字符串验证时，推荐使用）
3.  (()) ： 中括号旁边和运算符两边必须添加空格 （数字验证时，推荐使用）
4.  [[]] 和 (()) 分别是\[ ]的针对数学比较表达式和字符串表达式的加强版。
5.  使用\[\[ ... ]]条件判断结构，而不是\[ ... ]，能够防止脚本中的许多逻辑错误。比如，&&、||、<和> 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在\[ ]结构中的话，会报错。比如可以直接使用if \[\[ $a != 1 && $a != 2 ]], 如果不适用双括号, 则为if \[ $a -ne 1] &&\[ $a != 2 ]或者if \[ $a -ne 1 -a $a != 2 ]。  
    [[ ]]中增加模式匹配特效；  
    (( ))不需要再将表达式里面的大小于符号转义，除了可以使用标准的数学运算符外，还增加了以下符号

输出
- echo 仅用于字符串的输出，
- printf
printf 不会像 echo 自动添加换行符，我们可以手动添加 \n  
无大括号，直接以空格分隔
-   格式：printf format-string \[arguments...] 其中（format-string: 格式控制字符串、arguments: 参数列表）
-   案例：printf "%-10s %-8s %-4.2f\n" 郭靖 男 66.1234

-   %s %c %d %f 都是格式替代符
-   %d：Decimal 十进制整数 对应位置参数必须是十进制整数
-   %s：String 字符串 对应位置参数必须是字符串或者字符型 
-   %c：Char 字符 对应位置参数必须是字符串或者字符型 
-   %f：Float 浮点 对应位置参数必须是数字型
-   %-10s ： 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。
-   %-4.2f ：指格式化为小数，宽度为4个字符，其中.2指保留2位小数。

-   转义符：
-   \\a ：警告字符，通常为ASCII的BEL字符
-   \\b ：后退
-   \\c ：抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略
-   \\f ：换页（formfeed）
-   \\n ：换行
-   \\r ：回车（Carriage return）
-   \\t ：水平制表符
-   \\v ：垂直制表符
-   \\ ：一个字面上的反斜杠字符
-   \\ddd ：表示1到3位数八进制值的字符。仅在格式字符串中有效
-   \\0ddd ：表示1到3位的八进制值字符

流程控制
和Java、PHP等语言不一样，sh的流程控制不可为空，即if或者else的大括号中无任何语句




























