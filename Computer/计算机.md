计算机运作的基本流程
计算机主体有： CPU ，内存条， 硬盘， 显卡(GPU)，主板，显示器，外设
一个程序的运作流程：
1.CPU无法直接处理硬盘中的数据，计算机先把硬盘的数据/文件调入内存中，再通过CPU处理。CPU再将处理完的信息传递到显示器、显卡、声卡。
2.运行程序会占用内存的一段空间，那么这个空间暂时归于这个程序使用。只有当关闭程序后，此空间才会被释放清空(释放可能不完全，有垃圾值)

编码
进制



# 进制

- 常见的进制： 
二进制:逢二进一 ​ 八进制:逢八进一 ​ 十进制:逢十进一 ​ 十六进制:逢十六进一
2: 0 1 10 11 100 101 110 111 1000 1001 1010 1011 1100 1101 1111 10000 
8: 0 1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20   ---1代表8 
16: 0 1 2 3 4 5 6 7 8 9 a b c d e f 10 11才想

- 其他进制向十进制转换： 
8进制：1234 10进制：1 * 83+2 * 82+3 * 81+4 * 80

- 十进制向其他进制转换：
就是拿数字10取出那个进制的数，然后余数合起来
(185)10=(271)8
 185/8=23··· ···1
 23/8=2··· ···7 等价于 185/82=2··· ···7
 2/8=0··· ···2 等价于 185/83=0··· ···2

进制在C语言的使用
- 如何在程序中表示一个进制常量：
   八进制：0+数字序列
          十六进制：0x/X+数字序列
  0x17 那么这个数在计算机里表示 11
- 以不同进制形式输出：
 %d十进制
     %x/X十六进制
     %o八进制

# 存储数据的单位

- 位 bit (比特)
最小的存储单元（1 bit 存放0/1）
- 字节 byte
1 byte = 8 bit
计算机只能最小访问到字节
- more
1KB =1024byte
1MB = 1024KB
1GB = 1024MB

# 补码

原码 , 反码 , 补码
1.  8bit = 1byte 1位有0,1两种形式，8位即1字节有28=256种形式/数，即0~255
2.  原码： -2 ---原--> 1000 0010 // 8位 ​ 正负用最高位数表示，剩余的是绝对值 ​ 0:正 1:负
3.  反码：正数 = 原码
 负数--->除符号位其他位取反 - 2---反--->1111 1101
1.  补码：正数 =原码 computer都用补码方式存储数据  
     负数--->反码进一 - 2---反--->1111 1110
    为什么用补码？
    为使加法器能同时实现加法和减法的运算，就不用加减法器
    例： 1 - 1 = 1 +（-1） = 0
     1.原----->0000 0001 + 1000 0001 =1000 0010 =- 2 错误
     2.反----->0000 0001 + 1111 1110 =1111 1111 ---原--> 1000 0000 = -0 = 0 而0000 0000也是0，两个编码都代表0，错误
     3.补----->0000 0001 + 1111 1111 =0000 0000 = 0 正确 //此时会高位溢出，舍弃最高位的数
    用补码存储数据：拿出来运算，正数就是原码，负数用补码:现将原码转换为补码,相加得到的数再转换成原码
    为什么补码可以这样，详细请看：[b站视频](https://www.bilibili.com/video/BV1HJ411c7SS/?spm_id_from=333.999.0.0&vd_source=f9f8cac9b9498a739799b86cb6e5e696)
    注:
1.  1111 1111可以表示两种数，有符号(补码)时是 -1，无符号(原码)时是255
2.  -5 ------> 5 = 0101 ------->1010--->1011
整数是以补码的形式转化为二进制代码存储在计算机中
浮点数是以IEEE754标准转化为二进制代码存储在计算机中


整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。

# IO
IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。

比如你打开浏览器，访问新浪首页，浏览器这个程序就需要通过网络IO获取新浪的网页。浏览器首先会发送数据给新浪服务器，告诉它我想要首页的HTML，这个动作是往外发数据，叫Output，随后新浪服务器把网页发过来，这个动作是从外面接收数据，叫Input。所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。

IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。

由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：

第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；

另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。

同步和异步的区别就在于是否等待IO执行的结果。好比你去麦当劳点餐，你说“来个汉堡”，服务员告诉你，对不起，汉堡要现做，需要等5分钟，于是你站在收银台前面等了5分钟，拿到汉堡再去逛商场，这是同步IO。

你说“来个汉堡”，服务员告诉你，汉堡需要等5分钟，你可以先去逛商场，等做好了，我们再通知你，这样你可以立刻去干别的事情（逛商场），这是异步IO。

很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。

操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外。我们后面会详细讨论Python的IO编程接口。



# 正则表达式



## 字符



| 元字符 |                    描述                    |
| :----: | :----------------------------------------: |
|   .    |              匹配任意单个字符              |
|   []   |   定义一个字符集，匹配其中的任意一个字符   |
|  [^]   |     否定字符，匹配除了括号中的任意字符     |
|   *    |        匹配前面的子表达式零次或多次        |
|   +    |        匹配前面的子表达式一次或多次        |
|   ?    |        匹配前面的子表达式零次或一次        |
| {n,m}  |     匹配前面的子表达式至少n次，最多m次     |
|  {n}   |         匹配前面的子表达式恰好n次          |
| (xyz)  | 分组，将括号内的表达式作为一个整体进行匹配 |
|   \|   |     或，表示匹配前面两个表达式中的一个     |
|   \    | 转义字符，用于匹配特殊字符（如`.`、`*`等） |
|   ^    |              匹配字符串的开头              |
|   $    |              匹配字符串的结尾              |



| 特殊字符 |                             描述                             |
| :------: | :----------------------------------------------------------: |
|    \d    |                 (digit)匹配数字，相当于[0-9]                 |
|    \D    |                  不匹配数字，相当于\[^0-9]                   |
|    \s    | (space)匹配空白字符(包括空格、换行符、制表符等)，<br />相当于[\t\n\r\f\v] |
|    \S    |                        不匹配空白字符                        |
|    \w    |           (word)匹配字符(中文、字母、数字、下划线)           |
|    \W    |        不匹配字符，匹配特殊字符，如$、&、空格、\n、\t        |



```python
import re
#[]
str='孙悟空7猪八戒6_\n '
re.findall('[0-9]',str)
>>>['7', '6']
re.findall('[^0-9]',str)
>>>['孙', '悟', '空', '猪', '八', '戒', '_', '\n', ' ']
re.findall('\d',str)
>>>['7', '6']
re.findall('\D',str)
>>>['孙', '悟', '空', '猪', '八', '戒', '_', '\n', ' ']
re.findall('\w',str)
>>>['孙', '悟', '空', '7', '猪', '八', '戒', '6', '_']
re.findall('\W',str)
>>>['\n', ' ']
re.findall('\s',str)
>>>['\n', ' ']
re.findall('\S',str)
>>>['孙', '悟', '空', '7', '猪', '八', '戒', '6', '_']

#[]中的每单个字符是'或'的关系
str='你好'
re.findall('你好',str)
>>>['你好']
re.findall('[你好]',str)
>>>['你', '好']

str='Excel 45Word45PPT12Exce22Excell'
re.findall('[0-9a-zA-Z]{3,6}',str)  #{}匹配3-6个相应字符连起来的字符串
>>>['Excel', '45Word', '45PPT1', '2Exce2', '2Excel']
re.findall('Excel*',str)   #*前面的l出现0-无穷次
>>>['Excel', 'Exce', 'Excell']
re.findall('Excel+',str)   #+前面的l出现1-无穷次
>>>['Excel', 'Excell']
re.findall('Excel?',str)   #?前面的l出现0-1次，相当于boolean，有/无
>>>['Excel', 'Exce', 'Excel']
re.findall('(Excel)',str) #分组查找整个字符串
>>>['Excel', 'Excel']

str='13971810550'
re.findall('^\d{8,11}$',str) #字符串必须从数字开始，数字结束
>>>['13971810550']
str='A13971810550'
re.findall('^\d{8,11}$',str)
>>>[]
```



匹配模式参数

| 参数 |                             描述                             |
| :--: | :----------------------------------------------------------: |
| re.I |                    忽略大小写(ignorecase)                    |
| re.M |           多行模式，改变’^’和’$’的行为(multiline)            |
| re.S |            点任意匹配模式，改变’.’的行为(dotall)             |
| re.U | 使预定字符类 \w \W \b \B \s \S \d \D 取决于unicode定义的字符属性(unicode) |
| re.X | 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释(verbose) |
| re.L |  使预定字符类 \w \W \b \B \s \S 取决于当前区域设定(locale)   |

```python
import re
str = 'abcFBI\nabcCIAabc'
re.findall('fbi',str,re.I)
>>>['FBI']
re.findall('fbi.{1}',str,re.I|re.S)
>>>['FBI\n']
```



函数

|    函数名    |                        描述                        |
| :----------: | :------------------------------------------------: |
| re.complie() |  将正则表达式编译为模式对象，以便在后续操作中使用  |
| re.search()  | 在整个字符串中搜索匹配的模式，返回第一个匹配的结果 |
|  re.match()  |  从字符串的开头开始匹配模式，返回第一个匹配的结果  |
| re.findall() |             返回字符串中所有匹配的模式             |
|   re.sub()   |      用指定的字符串替换匹配的模式(substitude)      |
|  re.split()  |              根据匹配的模式分割字符串              |



```python
import re
#re.sub() 返回的是一个字符串，不是列表
str='abcFBIabcFBIaFBICIAabc'
re.sub('FBI','AAA',str) 
>>>abcAAAabcAAAaAAACIAabc
re.sub('FBI','AAA',str,1) #参数1：匹配结果只替换1次
>>>abcAAAabcFBIaFBICIAabc

#把函数作为参数传递
def 函数名(形参):
    pass
re.sub('FBI',函数名,str,1)
>>>abcabcFBIaFBICIAabc #第一个FBI没了，因为将第一个'FBI'传入但木有return 

str='C52730A52730D52730'
def 函数名(形参):
	分段获取 = 形参.group()
	if int(分段获取) >= 5:
		return '9'
	else:
		return '0'
re.sub('\d',函数名,str) #匹配到的字符直接传入函数的形参中，再替换成返回值
>>>C90900A90900D90900

#group分组，group的正则表达式必须是()分了组的
str='123abc567'
r=re.search("([0-9]*)([a-z]*)([0-9]*)",str #返回整体，跟group()一致
r.group(0)
>>>123abc567
r.group(1)       
>>>123
r.group(2)
>>>abc
r.group(3)
>>>567
r.group(0,1,2) #多个参数，返回元组
>>>('123abc567', '123', 'abc') 
r.groups() #返回所有分组
>>>('123', 'abc', '567')

#re.compile，是将正则表达式转换为模式对象。相当于're.I'这类
#从compile()函数的定义中，可以看出返回的是一个匹配对象，它单独使用就没有任何意义，需要和findall(), search(), match(）搭配使用。compile()与findall()一起使用，返回一个列表。
str='0355-67796666'            
a=re.compile(r'\d+-\d{8}')
re.findall(a,str)
>>>['0355-67796666']
re.findall(r'\d+-\d{8}',a)
>>>['0355-67796666']  

#re.match:从字符串的第一个字符开始匹配，如果未匹配到返回None，匹配到则返回一个对象
str='A83C72D1D8E67'
re.match('\d',str)
>>>None

#re.search:与match有点类似，只是搜索整个字符串，然后返回第一个匹配搭配的字符
str='A83C72D1D8E67'
re.search('\d',str)
>>><re.Match object; span=(1, 2), match='8'>
re.search('\d',str).group() #group获取匹配到的数字
>>>8
```



```python
#匹配电子邮箱地址
import re
email = "example@example.com"
pattern = r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$"
re.match(pattern, email)

```

























